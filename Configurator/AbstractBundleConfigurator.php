<?php

/*
 * This file is part of the QuickInstallBundle package.
 *
 * (c) EXSyst
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace EXSyst\Bundle\QuickInstallBundle\Configurator;

use EXSyst\Bundle\QuickInstallBundle\Bundle;
use EXSyst\Bundle\QuickInstallBundle\Util\Config\ConfigResolver;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\DependencyInjection\Extension\ConfigurationExtensionInterface;
use Symfony\Component\HttpKernel\KernelInterface;

abstract class AbstractBundleConfigurator extends AbstractConfigurator
{
    private $kernel;
    private $genericConfigurator;
    private $configFile;

    public function __construct(KernelInterface $kernel, GenericBundleConfigurator $genericConfigurator)
    {
        $this->kernel = $kernel;
        $this->genericConfigurator = $genericConfigurator;
    }

    /**
     * {@inheritdoc}
     */
    public function configure(Bundle $bundle, SymfonyStyle $io)
    {
        if (!$this->genericConfigurator->configure($bundle, $io)) {
            return;
        }

        if (!$this->shouldBeConfigured($bundle, $io)) {
            return;
        }
    }

    abstract protected function getExtension(Bundle $bundle): ConfigurationExtensionInterface;

    /**
     * @param mixed $config the new bundle config
     */
    final protected function saveConfig($config, Bundle $bundle, SymfonyStyle $io)
    {
        list($extension, $configFile) = $this->getDefaultValues($bundle, $io);
        $yaml = Yaml::parse(file_get_contents($configFile));
        $yaml[$extension->getAlias()] = $config;

        file_put_contents($configFile, Yaml::dump($yaml));

        $io->block(sprintf('"%s" has been updated! We advise you to keep at least two generated files: config_generated.yml and config_dev_generated.yml. You should import in them your own config files (config.yml and config_dev.yml) to let the plugin be aware of them and you should update your kernel to use the generated files.', $configFile), null, 'comment');
    }

    final protected function getConfig(Bundle $bundle, SymfonyStyle $io, $default = []): array
    {
        list($extension, $configFile) = $this->getDefaultValues($bundle, $io);

        if (file_exists($configFile)) {
            $yaml = Yaml::parse(file_get_contents($configFile));

            if (isset($yaml[$extension->getAlias()])) {
                return $yaml[$extension->getAlias()];
            }
        }

        return $default;
    }

    final protected function getAppConfig(Bundle $bundle, SymfonyStyle $io): array
    {
        list($extension, $configFile) = $this->getDefaultValues($bundle, $io);
        $configResolver = new ConfigResolver();

        return $configResolver->getConfig($this->kernel, $extension, $configFile);
    }

    private function getDefaultValues(Bundle $bundle, SymfonyStyle $io)
    {
        $extension = $this->getExtension($bundle);
        $configFile = $this->getConfigFile($bundle, $io);

        return [$extension, $configFile];
    }

    private function getConfigFile(Bundle $bundle, SymfonyStyle $io)
    {
        if (null === $this->configFile) {
            $default = '/config/config_generated.yml';

            $output->block('Warning: any formatting in the config file generated by the library will be lost. Ensure that the file you choose doesn\'t contain important comments. The file path is relative to your kernel path. Only Yaml is supported for now.', null, 'comment');

            $result = $this->ask($io, 'In which file do you want to save your config?', $default);

            $rootDir = $this->kernel->getRootDir();
            $this->configFile = $rootDir.$result;
            touch($this->configFile);
        }

        return $this->configFile;
    }
}
